<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>
    <script>
        //循环 遍历 迭代
        //循环 语言层面的语法->重复执行一段程序的代码
        //遍历 业务层面的做法->观察者获取集合中的元素的一种做法
        //迭代 实现层面的概念->实现遍历的底层方案其实就是迭代

        //针对数组的遍历方法 7个 foreach map filter reduce reduceRight some every
        //for in 对象的遍历方法
        //for...in语句以任意顺序遍历一个 对象 的除Symbol以外的可枚举属性。

        var obj = {
            a:1,
            b:2,
            c:3
        }
        // for(var key in obj){
        //     console.log(key,obj[key]);
        //     // 找的是对象的属性键名
        // }

        var arr = [1,2,3];
        // for(var key in arr){
        //     console.log(key,arr[key]);
        // }

        var m = new Map([[{a:1},1],[{b:2},2],[{c:3},3]])
        var s = new Set(['a','b','c']);

        // for(let key in m){
        //     console.log(key);
        // }for(let key in s){
        //     console.log(key);
        // }

        //for...of语句在可迭代对象
        //（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）
        //上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句
        // object无序 不可迭代

        //Symbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for...of 循环使用。
        //Array.prototype TypedArray.prototype String.prototype Map.prototype Set.prototype

        //key=>键名 value=>键值
        // for(let v of arr){
        //     console.log(v)
        // }

        // const allLi = document.getElementsByTagName('li');
        // console.log(allLi)
        // for(let li of allLi){
        //     console.log(li.innerHTML)
        // }
        // for(let [k,v] of m){
        //     console.log(k,v)
        // }

        // const str = '12345';
        // for(let s of str){
        //     console.log(s)
        // }

        //生成器 -> 生成 返回一个迭代器
        // function * generator(arr){
        //     for(let v of arr){
        //         yield v;
        //     }
        // }
        // const iterator = generator(arr);
        // console.log(iterator)

        // console.log(iterator.next().value)

        // function generator (arr){
        //     let nextIndex = 0;
        //     return {
        //         next(){
        //             return nextIndex < arr.length
        //             ? 
        //             {value: arr[nextIndex++],done:false} 
        //             :
        //             {value: undefined,done:true}
        //         }
        //     }
        // } 
        // const iterator = generator(arr);
        // console.log(iterator)
        // console.log(iterator.next());
        // console.log(iterator.next());
        // console.log(iterator.next());
        // console.log(iterator.next());

        //类数组
        // const o = {
        //     0:1,
        //     1:2,
        //     2:3,
        //     length:3
        // }
        // Object.prototype[Symbol.iterator] = iterator;
        // function iterator(){
        //     var index = 0;
        //     var _this = this;
        //     return {
        //         next(){
        //             return index < _this.length
        //             ?
        //             {value:_this[index++],done:false}
        //             :
        //             {value:undefined,done:true}
        //         }
        //     }
        // }
        // for(let v of o){
        //     console.log(v)
        // } 
        Object.prototype.[Symbol.iterator] = ()=> {
            let index = 0;
            return {
                next
            }
        }
    </script>
</body>
</html>