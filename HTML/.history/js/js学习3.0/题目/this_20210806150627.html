<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //this js关键字 当前环境执行期上下文对象的一个属性 
        //this 在不同的环境 不用作用下 表现是不同的
        //全局作用域的this -> 全局对象
        //window和this的关系

        // console.log(this === window);//true

        // var a = 1;
        // var b = function(){ return 'function'};
        // // console.log(window.a === a);//true
        // // console.log(window.b === b);//true

        // console.log(a);
        // console.log(b);

        // window.aa = 1;
        // window.bb = function(){ return 'function'};
        // console.log(aa);
        // console.log(bb);

        // this.aa = 1;
        // this.bb = function(){ return 'function'};
        // console.log(aa);
        // console.log(bb);

        // var a = 'global -> a';
        // var obj = {
        //     a:'obj -> a',
        //     test: function(){
        //         console.log(this.a);
        //         console.log(window.a);
        //     }
        // }
        // obj.test();
        //obj -> a  global -> a
        //在node环境下 window is not defined
        //若将window.a换成global.a  打印undefined
        //在node环境下 需要挂载到global上

        //获取全局对象 web:window,self,frames,this
        //            node:global
        //            worker:self
        //  通用对象 globalThis

        // var a = 'global -> a';
        // var obj = {
        //     a:'obj -> a',
        //     test: function(){
        //         console.log(this.a);
        //         console.log(window.a);//global -> a
        //         console.log(self.a);  //global -> a
        //         console.log(frames.a);//global -> a
        //     }
        // }
        // obj.test();

        // function test(){
        //     'use strict'
        //     return this;
        // }
        // console.log(test()); //undefined 在严格模式下
        // console.log(window.test());//window
        // //谁调用函数 函数内部的执行默认就是谁

    //类**************************************************************** 

        //类的本质就是函数
        //类 class xxx -> 容器/作用域/模块
        // class Test1{
        //     constructor(){

        //     }
        //     say(){

        //     }
        //     static do(){

        //     }
        // }
        // const test1 = new Test1();

        // function Test2(){  //相当于 constructor

        // };
        // Test2.prototype.say = function(){

        // };
        // Test2.do = function(){};
  
        // class Test {
        //     constructor(){
        //         //类的非静态方法 会在实例化过程中添加到this上
        //         //new - this this->{function () {}}
        //         this.test = function(){
        //             console.log('none-static' + this);
        //         }
        //     }

        //     // 类的静态方法  -> Test.prototypr{...}
        //     // new 生成新的this this -> {} -> _proto_ -> Test.prototype
        //     test(){
        //         console.log('static' + this);
        //         console.log(this===test1);
        //         console.log(this===Test);
        //     }
        // }
        // //this->{} 实例化对象 时 this 指向
        // const test1 = new Test();

        // test1.test()//在test中的this仍然指向实例化出来的对象

    //     const testA = Object.create(null);//指定原型 prototype 指向
    //     console.log(testA)//__proto__ 没有

    //     const testB = {};
    //     console.log(testB)//__proto__ Object

    //继承**************************************************************** 
    // class Father{
    //     constructor(){
    //         //基类 没有this
    //         // new -> this -> {} -> 添加age属性
    //         this.age = 44;
    //     }
    //     swim(){
    //         console.log('Go swimming!!!');
    //     }
    // }
    // class Son extends Father{
    //     constructor(){
    //         super();
    //         this.hobby = 'traval';
    //         console.log(this.age);//能访问到this 
    //         //super 调用Father 上的 constructor
    //         //生成了this的绑定 Father上的this 指向了son的实例
    //         //相当于执行了 this -> new Father() -> {} 然后才能继续给this上添加东西
    //     }
    //     // 不加super报错： derived class派生类 
    //     study (){
    //         console.log(this);//this指向Son的实例
    //         this.swim();
    //     }
    // }
    // const son = new Son();
    // son.study();//继承之后 能打印出来 Go swimming!!!
    // // 这个方法在 son.__proto__ 指的 Father Father原型上的方法有swim

    //call apply bind**************************************************************** 

    // var obj = {
    //     a: 1
    // }
    // var obj2 = {
    //     a: 100
    // }
    // var a = 2;

    // function test (b,c) {
    //     // this 默认指向window
    //     // 用了call之后 1
    //     console.log(this.a,b,c);
    // }

    // test(3,4);

    // test.call(obj,3,4);
    // test.apply(obj,[3,4]);
    //bind不是立即执行 而是返回一个新函数

     // bind 只会生效一次 
    // var test1 = test.bind(obj,3,4);
    // test1();

    // var test2 = test1.bind(obj2,3,4);
    // test2();

    // var t = test.bind(obj2,3,4).bind(obj,3,4);//100 3 4
    // t();

    //箭头函数的this*************************************************************** 
        // 'use strict'
        // const test = () => {
        //     console.log(this); //window
        // }
        // test();

        var obj = {
            a: 1
        }
        // var a = 2;

        // const test = () => {
        //     console.log(this.a);
        // }

        // test();//2
        // test.call(obj);//2
        //箭头函数忽略任何形式的this指向的改变
        //静态this指向

        // new test();//箭头函数一定不是一个构造器
        
        // obj.test = () => {
        //     //箭头函数中的this不是谁绑定指向谁
        //     console.log(obj);
        //     console.log(this);
        // }
        // obj.test();

        // obj.test = function(){
        //         var t = () => {
        //         //this->obj
        //         console.log(this);
        //     }
        //     t();
        // }
        // obj.test();

        // obj.test = function(){
        //     setTimeout(() => {
        //         //this——>obj
        //         console.log(this);
        //     },0)
        // }
        // obj.test();

        // obj.test = function(){
        //     var t1 = () => {
        //         //this -> obj
        //         var t2 = () => {
        //             console.log(this);
        //         }
        //         t2();
        //     }
        //     t1();
        // }
        // obj.test();

        obj.test = function(){
            var t1 = function() {
                //this -> window
                var t2 = () => {
                    console.log(this);
                }
                t2();
            }
            t1();
        }
        obj.test();

        //箭头函数中的this指向外层作用域(非箭头函数)的this
    </script>
</body>
</html>